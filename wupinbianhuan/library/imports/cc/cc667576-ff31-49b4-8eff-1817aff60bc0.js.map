{"version":3,"sources":["../../../../../assets/scripts/collections/assets/scripts/collections/Dictionary.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../../assets/scripts/collections","sourcesContent":["import * as util from './util';\n\n// Used internally by dictionary\nexport interface IDictionaryPair<K, V> {\n    key: K;\n    value: V;\n}\n\nexport default class Dictionary<K, V> {\n\n    /**\n     * Object holding the key-value pairs.\n     * @type {Object}\n     * @private\n     */\n    protected table: { [key: string]: IDictionaryPair<K, V> };\n    //: [key: K] will not work since indices can only by strings in javascript and typescript enforces this.\n\n    /**\n     * Number of elements in the list.\n     * @type {number}\n     * @private\n     */\n    protected nElements: number;\n\n    /**\n     * Function used to convert keys to strings.\n     * @type {function(Object):string}\n     * @protected\n     */\n    protected toStr: (key: K) => string;\n\n\n    /**\n     * Creates an empty dictionary.\n     * @class <p>Dictionaries map keys to values; each key can map to at most one value.\n     * This implementation accepts any kind of objects as keys.</p>\n     *\n     * <p>If the keys are custom objects a function which converts keys to unique\n     * strings must be provided. Example:</p>\n     * <pre>\n     * function petToString(pet) {\n     *  return pet.name;\n     * }\n     * </pre>\n     * @constructor\n     * @param {function(Object):string=} toStrFunction 可选函数，用于将键转换为字符串。\n     * 如果键不是字符串，或者toString()不合适，则必须提供一个接收键并返回惟一字符串的自定义函数。\n     */\n    constructor(toStrFunction?: (key: K) => string) {\n        this.table = {};\n        this.nElements = 0;\n        this.toStr = toStrFunction || util.defaultToString;\n    }\n\n\n    /**\n     * Returns the value to which this dictionary maps the specified key.\n     * Returns undefined if this dictionary contains no mapping for this key.\n     * @param {Object} key key whose associated value is to be returned.\n     * @return {*} the value to which this dictionary maps the specified key or\n     * undefined if the map contains no mapping for this key.\n     */\n    getValue(key: K): V | undefined {\n        const pair: IDictionaryPair<K, V> = this.table['$' + this.toStr(key)];\n        if (util.isUndefined(pair)) {\n            return undefined;\n        }\n        return pair.value;\n    }\n\n\n    /**\n     * Associates the specified value with the specified key in this dictionary.\n     * If the dictionary previously contained a mapping for this key, the old\n     * value is replaced by the specified value.\n     * @param {Object} key key with which the specified value is to be\n     * associated.\n     * @param {Object} value value to be associated with the specified key.\n     * @return {*} previous value associated with the specified key, or undefined if\n     * there was no mapping for the key or if the key/value are undefined.\n     */\n    setValue(key: K, value: V): V | undefined {\n\n        if (util.isUndefined(key) || util.isUndefined(value)) {\n            return undefined;\n        }\n\n        let ret: V | undefined;\n        const k = '$' + this.toStr(key);\n        const previousElement: IDictionaryPair<K, V> = this.table[k];\n        if (util.isUndefined(previousElement)) {\n            this.nElements++;\n            ret = undefined;\n        } else {\n            ret = previousElement.value;\n        }\n        this.table[k] = {\n            key: key,\n            value: value\n        };\n        return ret;\n    }\n\n    /**\n     * Removes the mapping for this key from this dictionary if it is present.\n     * @param {Object} key key whose mapping is to be removed from the\n     * dictionary.\n     * @return {*} previous value associated with specified key, or undefined if\n     * there was no mapping for key.\n     */\n    remove(key: K): V | undefined {\n        const k = '$' + this.toStr(key);\n        const previousElement: IDictionaryPair<K, V> = this.table[k];\n        if (!util.isUndefined(previousElement)) {\n            delete this.table[k];\n            this.nElements--;\n            return previousElement.value;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns an array containing all of the keys in this dictionary.\n     * @return {Array} an array containing all of the keys in this dictionary.\n     */\n    keys(): K[] {\n        const array: K[] = [];\n        for (const name in this.table) {\n            if (util.has(this.table, name)) {\n                const pair: IDictionaryPair<K, V> = this.table[name];\n                array.push(pair.key);\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Returns an array containing all of the values in this dictionary.\n     * @return {Array} an array containing all of the values in this dictionary.\n     */\n    values(): V[] {\n        const array: V[] = [];\n        for (const name in this.table) {\n            if (util.has(this.table, name)) {\n                const pair: IDictionaryPair<K, V> = this.table[name];\n                array.push(pair.value);\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Executes the provided function once for each key-value pair\n     * present in this dictionary.\n     * @param {function(Object,Object):*} callback function to execute, it is\n     * invoked with two arguments: key and value. To break the iteration you can\n     * optionally return false.\n     */\n    forEach(callback: (key: K, value: V) => any): void {\n        for (const name in this.table) {\n            if (util.has(this.table, name)) {\n                const pair: IDictionaryPair<K, V> = this.table[name];\n                const ret = callback(pair.key, pair.value);\n                if (ret === false) {\n                    return;\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns true if this dictionary contains a mapping for the specified key.\n     * @param {Object} key key whose presence in this dictionary is to be\n     * tested.\n     * @return {boolean} true if this dictionary contains a mapping for the\n     * specified key.\n     */\n    containsKey(key: K): boolean {\n        return !util.isUndefined(this.getValue(key));\n    }\n\n    /**\n     * Removes all mappings from this dictionary.\n     * @this {collections.Dictionary}\n     */\n    clear() {\n        this.table = {};\n        this.nElements = 0;\n    }\n\n    /**\n     * Returns the number of keys in this dictionary.\n     * @return {number} the number of key-value mappings in this dictionary.\n     */\n    size(): number {\n        return this.nElements;\n    }\n\n    /**\n     * Returns true if this dictionary contains no mappings.\n     * @return {boolean} true if this dictionary contains no mappings.\n     */\n    isEmpty(): boolean {\n        return this.nElements <= 0;\n    }\n\n    toString(): string {\n        let toret = '{';\n        this.forEach((k, v) => {\n            toret += `\\n\\t${k} : ${v}`;\n        });\n        return toret + '\\n}';\n    }\n} // End of dictionary\n"]}