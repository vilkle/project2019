{"version":3,"sources":["arrays.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../../assets/scripts/collections","sourcesContent":["import * as util from './util';\n\n/**\n * Returns the position of the first occurrence of the specified item\n * within the specified array.4\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the first occurrence of the specified element\n * within the specified array, or -1 if not found.\n */\nexport function indexOf<T>(array: T[], item: T, equalsFunction?: util.IEqualsFunction<T>): number {\n    const equals = equalsFunction || util.defaultEquals;\n    const length = array.length;\n    for (let i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * Returns the position of the last occurrence of the specified element\n * within the specified array.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the position of the last occurrence of the specified element\n * within the specified array or -1 if not found.\n */\nexport function lastIndexOf<T>(array: T[], item: T, equalsFunction?: util.IEqualsFunction<T>): number {\n    const equals = equalsFunction || util.defaultEquals;\n    const length = array.length;\n    for (let i = length - 1; i >= 0; i--) {\n        if (equals(array[i], item)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * Returns true if the specified array contains the specified element.\n * @param {*} array the array in which to search the element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the specified array contains the specified element.\n */\nexport function contains<T>(array: T[], item: T, equalsFunction?: util.IEqualsFunction<T>): boolean {\n    return indexOf(array, item, equalsFunction) >= 0;\n}\n\n\n/**\n * Removes the first ocurrence of the specified element from the specified array.\n * @param {*} array the array in which to search element.\n * @param {Object} item the element to search.\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\n * check equality between 2 elements.\n * @return {boolean} true if the array changed after this call.\n */\nexport function remove<T>(array: T[], item: T, equalsFunction?: util.IEqualsFunction<T>): boolean {\n    const index = indexOf(array, item, equalsFunction);\n    if (index < 0) {\n        return false;\n    }\n    array.splice(index, 1);\n    return true;\n}\n\n/**\n * Returns the number of elements in the specified array equal\n * to the specified object.\n * @param {Array} array the array in which to determine the frequency of the element.\n * @param {Object} item the element whose frequency is to be determined.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between 2 elements.\n * @return {number} the number of elements in the specified array\n * equal to the specified object.\n */\nexport function frequency<T>(array: T[], item: T, equalsFunction?: util.IEqualsFunction<T>): number {\n    const equals = equalsFunction || util.defaultEquals;\n    const length = array.length;\n    let freq = 0;\n    for (let i = 0; i < length; i++) {\n        if (equals(array[i], item)) {\n            freq++;\n        }\n    }\n    return freq;\n}\n\n/**\n * Returns true if the two specified arrays are equal to one another.\n * Two arrays are considered equal if both arrays contain the same number\n * of elements, and all corresponding pairs of elements in the two\n * arrays are equal and are in the same order.\n * @param {Array} array1 one array to be tested for equality.\n * @param {Array} array2 the other array to be tested for equality.\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\n * check equality between elemements in the arrays.\n * @return {boolean} true if the two arrays are equal\n */\nexport function equals<T>(array1: T[], array2: T[], equalsFunction?: util.IEqualsFunction<T>): boolean {\n    const equals = equalsFunction || util.defaultEquals;\n\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    const length = array1.length;\n    for (let i = 0; i < length; i++) {\n        if (!equals(array1[i], array2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Returns shallow a copy of the specified array.\n * @param {*} array the array to copy.\n * @return {Array} a copy of the specified array\n */\nexport function copy<T>(array: T[]): T[] {\n    return array.concat();\n}\n\n/**\n * Swaps the elements at the specified positions in the specified array.\n * @param {Array} array The array in which to swap elements.\n * @param {number} i the index of one element to be swapped.\n * @param {number} j the index of the other element to be swapped.\n * @return {boolean} true if the array is defined and the indexes are valid.\n */\nexport function swap<T>(array: T[], i: number, j: number): boolean {\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\n        return false;\n    }\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n    return true;\n}\n\nexport function toString<T>(array: T[]): string {\n    return '[' + array.toString() + ']';\n}\n\n/**\n * Executes the provided function once for each element present in this array\n * starting from index 0 to length - 1.\n * @param {Array} array The array in which to iterate.\n * @param {function(Object):*} callback function to execute, it is\n * invoked with one argument: the element value, to break the iteration you can\n * optionally return false.\n */\nexport function forEach<T>(array: T[], callback: util.ILoopFunction<T>): void {\n    for (const ele of array) {\n        if (callback(ele) === false) {\n            return;\n        }\n    }\n}\n"]}